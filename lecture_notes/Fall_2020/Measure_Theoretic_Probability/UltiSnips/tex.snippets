global !p
texMathZones = ['texMathZone' + x for x in ['A', 'AS', 'B', 'BS', 'C', 'CS', 'D', 'DS', 'E', 'ES', 'F', 'FS', 'G', 'GS', 'H', 'HS', 'I', 'IS', 'J', 'JS', 'K', 'KS', 'L', 'LS', 'DS', 'V', 'W', 'X', 'Y', 'Z', 'AmsA', 'AmsB', 'AmsC', 'AmsD', 'AmsE', 'AmsF', 'AmsG', 'AmsAS', 'AmsBS', 'AmsCS', 'AmsDS', 'AmsES', 'AmsFS', 'AmsGS' ]]
texIgnoreMathZones = ['texMathText']
texMathZoneIds = vim.eval('map('+str(texMathZones)+", 'hlID(v:val)')")
texIgnoreMathZoneIds = vim.eval('map('+str(texIgnoreMathZones)+", 'hlID(v:val)')")
ignore = texIgnoreMathZoneIds[0]
def math():
	synstackids = vim.eval("synstack(line('.'), col('.') - (col('.')>=2 ? 1 : 0))")
	try:
		first = next(i for i in reversed(synstackids) if i in texIgnoreMathZoneIds or i in texMathZoneIds)
		return first != ignore
	except StopIteration:
		return False
endglobal


context "math()"
snippet pp "phi,cs" iA
\phi
endsnippet

context "math()"
snippet PP "Phi,cs" iA
\Phi
endsnippet

context "math()"
snippet ww "omega,cs" iA
\omega
endsnippet

context "math()"
snippet WW "Omega,cs" iA
\Omega
endsnippet

snippet letw "let omega" iA
Let $\Omega$ be a non-empty set.
endsnippet

snippet sf "sigma field" iA
$\sigma$-field
endsnippet

context "math()"
snippet AA "fancy A" iA
\mathcal{A}
endsnippet

context "math()"
snippet FF "fancy F" iA
\mathcal{F}
endsnippet

context "math()"
snippet supr "supr" iA
\sup\{$1\} $0
endsnippet

context "math()"
snippet infi "infimum" iA
\inf\{$1\} $0
endsnippet

# vim:ft=snippets
