global !p
texMathZones = ['texMathZone' + x for x in ['A', 'AS', 'B', 'BS', 'C', 'CS', 'D', 'DS', 'E', 'ES', 'F', 'FS', 'G', 'GS', 'H', 'HS', 'I', 'IS', 'J', 'JS', 'K', 'KS', 'L', 'LS', 'DS', 'V', 'W', 'X', 'Y', 'Z', 'AmsA', 'AmsB', 'AmsC', 'AmsD', 'AmsE', 'AmsF', 'AmsG', 'AmsAS', 'AmsBS', 'AmsCS', 'AmsDS', 'AmsES', 'AmsFS', 'AmsGS' ]]
texIgnoreMathZones = ['texMathText']
texMathZoneIds = vim.eval('map('+str(texMathZones)+", 'hlID(v:val)')")
texIgnoreMathZoneIds = vim.eval('map('+str(texIgnoreMathZones)+", 'hlID(v:val)')")
ignore = texIgnoreMathZoneIds[0]
def math():
	synstackids = vim.eval("synstack(line('.'), col('.') - (col('.')>=2 ? 1 : 0))")
	try:
		first = next(i for i in reversed(synstackids) if i in texIgnoreMathZoneIds or i in texMathZoneIds)
		return first != ignore
	except StopIteration:
		return False
endglobal


context "math()"
snippet ww "omega,cs" iA
\omega
endsnippet

context "math()"
snippet WW "Omega,cs" iA
\Omega
endsnippet

snippet letw "let omega" iA
Let $\Omega$ be a non-empty set.
endsnippet

snippet sf "sigma field" A
$\sigma$-field
endsnippet

snippet ps "sigma field" A
$\pi$-system
endsnippet

snippet ls "sigma field" A
$\lambda$-system
endsnippet

context "math()"
snippet AA "fancy A" iA
\mathcal{A}
endsnippet

context "math()"
snippet FF "fancy F" iA
\mathcal{F}
endsnippet

context "math()"
snippet GG "fancy G" iA
\mathcal{G}
endsnippet

context "math()"
snippet MM "fancy M" iA
\mathcal{M}
endsnippet

context "math()"
snippet BB "fancy B" iA
\mathcal{B}
endsnippet

context "math()"
snippet PP "fancy P" iA
\mathcal{P}
endsnippet

context "math()"
snippet LL "fancy L" iA
\mathscr{L}
endsnippet

context "math()"
snippet supr "supremum" iA
\sup\left\\{$1 \right\\} $0
endsnippet

context "math()"
snippet infim "infimum" iA
\inf\left\\{$1 \right\\} $0
endsnippet

context "math()"
snippet limsup "limsup" iA
\limsup_{ ${1: n}} $0
endsnippet

context "math()"
snippet limifm "liminf" iA
\liminf_{ ${1: n}} $0
endsnippet

context "math()"
snippet NU "limsup NU" iA
\bigcap_{ ${1:n=${2: 1}}}^{\infty} \bigcup_{${3:k=${2: n}}}^{\infty} $0
endsnippet

context "math()"
snippet UN "limsup NU" iA
\bigcup_{ ${1:n=${2: 1}}}^{\infty} \bigcap_{${3:k=${2: n}}}^{\infty} $0
endsnippet

context "math()"
snippet up| "" iA
\\uparrow
endsnippet

context "math()"
snippet dw| "" iA
\\downarrow
endsnippet

context "math()"
snippet io.. "" iA
\text{ i.o. }

context "math()"
snippet aa.. "" iA
\text{ a.a. }
endsnippet

context "math()"
snippet xra "" iA
\xrightarrow{ $1} $0
endsnippet

context "math()"
snippet EE "expected value" iA
E\left[ $1 \right] $0
endsnippet

context "math()"
snippet VV "variance" iA
\var \left[ $1 \right] $0
endsnippet

context "math()"
snippet lbi "Lebesgue Integral" iA
\int_{ ${1: A}} ${2: f} \ d ${3: \mu} $0
endsnippet

# vim:ft=snippets
